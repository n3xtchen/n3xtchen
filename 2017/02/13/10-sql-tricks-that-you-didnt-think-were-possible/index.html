<!doctype html><html lang=zh-cn dir=ltr class=scroll-smooth data-default-appearance=light data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="zh-CN"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>你不知道的10个SQL杀手级特性 &#183; N3xtChen 的博客</title><meta name=title content="你不知道的10个SQL杀手级特性 &#183; N3xtChen 的博客"><link rel=canonical href=https://n3xtchen.github.io/n3xtchen/2017/02/13/10-sql-tricks-that-you-didnt-think-were-possible/><link type=text/css rel=stylesheet href=/n3xtchen/css/main.bundle.min.5775579083e26679417a451dd3d7c3e540c7be85426fba5a47019603552ac89b95e12dddb64138e0aa488d68bc318ec4b0820255a5859b4da3f1b45f140abf11.css integrity="sha512-V3VXkIPiZnlBekUd09fD5UDHvoVCb7paRwGWA1UqyJuV4S3dtkE44KpIjWi8MY7EsIICVaWFm02j8bRfFAq/EQ=="><script type=text/javascript src=/n3xtchen/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
<script defer type=text/javascript id=script-bundle src=/n3xtchen/js/main.bundle.min.41e474f5d66052b313c33b8f56008afac498015b7472d0f2ab78e22c187405fdff125b6735973309e4743b6924ca8c575db297f464c42da8e30ef9daed3b050c.js integrity="sha512-QeR09dZgUrMTwzuPVgCK+sSYAVt0ctDyq3jiLBh0Bf3/EltnNZczCeR0O2kkyoxXXbKX9GTELajjDvna7TsFDA==" data-copy data-copied></script>
<script src=/n3xtchen/js/zoom.min.js></script>
<link rel=icon href=/n3xtchen/favicon.png pe=image/png><meta property="og:title" content="你不知道的10个SQL杀手级特性"><meta property="og:description" content="TLDR;"><meta property="og:type" content="article"><meta property="og:url" content="https://n3xtchen.github.io/n3xtchen/2017/02/13/10-sql-tricks-that-you-didnt-think-were-possible/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-02-13T00:00:00+00:00"><meta property="article:modified_time" content="2017-02-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="你不知道的10个SQL杀手级特性"><meta name=twitter:description content="TLDR;"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"时间线","name":"你不知道的10个SQL杀手级特性","headline":"你不知道的10个SQL杀手级特性","abstract":"TLDR;","inLanguage":"zh-CN","url":"https:\/\/n3xtchen.github.io\/n3xtchen\/2017\/02\/13\/10-sql-tricks-that-you-didnt-think-were-possible\/","author":{"@type":"Person","name":"n3xtchen"},"copyrightYear":"2017","dateCreated":"2017-02-13T00:00:00\u002b00:00","datePublished":"2017-02-13T00:00:00\u002b00:00","dateModified":"2017-02-13T00:00:00\u002b00:00","mainEntityOfPage":"true","wordCount":"3776"}]</script><meta name=author content="n3xtchen"><link href=https://twitter.com/mN3XT rel=me><link href=https://githhub.com/n3xtchen rel=me><script src=/n3xtchen/lib/jquery/jquery.slim.min.js integrity></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EMLJCHXBFD"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EMLJCHXBFD")</script><meta name=theme-color><style>code.has-jax{-webkit-font-smoothing:antialiased;background:inherit!important;border:none!important;font-size:100%}</style><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span></a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/n3xtchen class="text-base font-medium text-gray-500 hover:text-gray-900">N3xtChen 的博客</a></nav><nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12"><a href=/n3xtchen/posts/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=时间线>时间线</p></a><a href=/n3xtchen/categories/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=分类页>分类</p></a><a href=/n3xtchen/tags/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Tags>标签</p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400 h-12" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="ltr:mr-14 rtl:ml-14 cursor-pointer text-sm text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"><button id=appearance-switcher aria-label="Dark mode switcher" type=button><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center space-x-5 md:ml-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button style=margin-right:5px><div class="flex items-center justify-center h-12 dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden h-12 dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/n3xtchen/posts/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=时间线>时间线</p></a></li><li class=mt-1><a href=/n3xtchen/categories/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=分类页>分类</p></a></li><li class=mt-1><a href=/n3xtchen/tags/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Tags>标签</p></a></li></ul></div></label></div></div><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">你不知道的10个SQL杀手级特性</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2017-02-13 00:00:00 +0000 UTC">2017-02-13</time><span class="px-2 text-primary-500">&#183;</span><span>3776 字</span><span class="px-2 text-primary-500">&#183;</span><span title=预计阅读>18 分钟</span></div><div class="flex flex-row flex-wrap items-center"></div></div><div class=flex><img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width=96 height=96 alt=n3xtchen src=/n3xtchen/images/author.jpg><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">作者</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">n3xtchen</div><div class="text-sm text-neutral-700 dark:text-neutral-400">Sharing Funny Tech With You</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://twitter.com/mN3XT target=_blank aria-label=Twitter rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://githhub.com/n3xtchen target=_blank aria-label=Github rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span></a></div></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first sm:max-w-prose lg:ml-auto px-0 lg:order-last lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden"></summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><ul><li><a href=#1-一切都是表>1. 一切都是表</a></li><li><a href=#2-使用递归sql来生成数据>2. 使用递归SQL来生成数据</a><ul><li><a href=#side-note图灵完备>Side note：图灵完备</a></li></ul></li><li><a href=#3-计算运行总计>3. 计算运行总计</a></li><li><a href=#中场休息>中场休息</a></li><li><a href=#4-寻找连续无间隔的最长子序列>4. 寻找连续无间隔的最长子序列</a></li><li><a href=#5-寻找序列长度>5. 寻找序列长度</a></li><li><a href=#6-子集和問題the-subset-sum-problem-with-sql>6. 子集和問題（The subset sum problem with SQL）</a></li><li><a href=#7-覆盖运行中的汇总>7. 覆盖运行中的汇总</a></li><li><a href=#8-时间序列模式识别time-series-pattern-recognition>8. 时间序列模式识别（Time Series Pattern Recognition）</a></li><li><a href=#9-数据表行列转换pivoting-and-unpivoting>9. 数据表行列转换（Pivoting and Unpivoting）</a></li><li><a href=#10-滥用-xml-和-json>10. 滥用 XML 和 JSON</a></li><li><a href=#解语>解语</a></li><li><a href=#附录-1-随机生成用户登录行为>附录-1: 随机生成用户登录行为:</a></li><li><a href=#附录-2-生成订单数据>附录-2: 生成订单数据：</a></li></ul></li></ul></nav></div></details><details class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden"></summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><ul><li><a href=#1-一切都是表>1. 一切都是表</a></li><li><a href=#2-使用递归sql来生成数据>2. 使用递归SQL来生成数据</a><ul><li><a href=#side-note图灵完备>Side note：图灵完备</a></li></ul></li><li><a href=#3-计算运行总计>3. 计算运行总计</a></li><li><a href=#中场休息>中场休息</a></li><li><a href=#4-寻找连续无间隔的最长子序列>4. 寻找连续无间隔的最长子序列</a></li><li><a href=#5-寻找序列长度>5. 寻找序列长度</a></li><li><a href=#6-子集和問題the-subset-sum-problem-with-sql>6. 子集和問題（The subset sum problem with SQL）</a></li><li><a href=#7-覆盖运行中的汇总>7. 覆盖运行中的汇总</a></li><li><a href=#8-时间序列模式识别time-series-pattern-recognition>8. 时间序列模式识别（Time Series Pattern Recognition）</a></li><li><a href=#9-数据表行列转换pivoting-and-unpivoting>9. 数据表行列转换（Pivoting and Unpivoting）</a></li><li><a href=#10-滥用-xml-和-json>10. 滥用 XML 和 JSON</a></li><li><a href=#解语>解语</a></li><li><a href=#附录-1-随机生成用户登录行为>附录-1: 随机生成用户登录行为:</a></li><li><a href=#附录-2-生成订单数据>附录-2: 生成订单数据：</a></li></ul></li></ul></nav></div></details></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="max-w-prose mb-20"><p>TLDR;</p><div id=1-一切都是表 class=anchor></div><h3 class="relative group">1. 一切都是表
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%e4%b8%80%e5%88%87%e9%83%bd%e6%98%af%e8%a1%a8 aria-label=锚点>#</a></span></h3><p>这是最微不足道的技巧，甚至不算一个技巧，但是它却是你全面了解 <strong>SQL</strong> 的基础：一切都是表！但你看到下面一段语句：</p><pre><code>SELECT * FROM person
</code></pre><p>&mldr;你很快注意到表 person。很棒，他是一张表。但是你意识到这整个语句也是一张表吗？举个例子，你可以写：</p><pre><code>SELECT * FROM (
  SELECT * FROM person
) t
</code></pre><p>现在，你已经创建一张派生表（derived table）- 一张嵌套在 <code>FROM</code> 子句的 <code>SELECT</code> 语句。</p><p>虽然这功能微不足道，但是很优雅。你也可创建一张使用 <code>VALUES()</code> 的 ad-hoc 的内存表，在一些数据库中（如，<strong>PostgreSQL</strong>，<strong>SQL Server</strong>）</p><pre><code>SELECT * FROM (VALUES(1), (2), (3))) t(a)
</code></pre><p>以及她的简单输出：</p><pre><code> a
---
 1
 2
 3
</code></pre><p>如果这个语法不知大，你可以把他转化成派生表，如，在 <strong>Oracle</strong> 中：</p><pre><code>SELECT * FROM (
	SELECT 1 AS a FROM DUAL UINION ALL
	SELECT 2 AS a FROM DUAL UINION ALL
	SELECT 3 AS a FROM DUAL
)
</code></pre><p>正如你所看到的， <code>VALUES()</code> 和派生表实际上都是一样的东西，从概念上讲。让我们重温下插入语句，两种方法：</p><pre><code>-- SQL Server, PostgreSQL, some others:
INSERT INTO my_table(a) VALUES (1), (2), (3);

-- Oracle, many others:
INSERT INTO my_table(a)
	SELECT 1 AS a FROM DUAL UINION ALL
	SELECT 2 AS a FROM DUAL UINION ALL
	SELECT 3 AS a FROM DUAL
</code></pre><p>SQL 中，一切都是表。当你插入数据到表，你并不是在插入独立的行。你实际上插入的是一张表。大部分人经常只在表冲插入一张一行的表，因此意识不到。</p><p>一切都是表。在 <strong>PostgreSQL</strong> 中，甚至连函数都是表：</p><pre><code>ichexw=# SELECT * FROM substring('abcde', 2, 3);
 substring
-----------
 bcd
(1 row)
</code></pre><p>如果你是个 <strong>JAVA</strong> 程序员，你可以使用 <strong>JAVA8</strong> Stream API 来类比它。考虑下，下面的相同的概念</p><pre><code>TABLE：	Stream&lt;Tuple&lt;..&gt;&gt;
SELECT:	map()
DISTINCT:	distinct()
JOIN:		flatMap()
WHERE/HAVING:	filter()
GROUP BY:	collect()
ORDER BY:	sorted()
UNION ALL:	concat()
</code></pre><p>使用 <strong>JAVA8</strong> 的过程中，“一切都是流”（至少在开始使用 Streams 的时候）。不管你怎么转换流，比如使用 <code>map()</code> 和 <code>filter()</code>，结果的类型永远都是一个流</p><div id=2-使用递归sql来生成数据 class=anchor></div><h3 class="relative group">2. 使用递归SQL来生成数据
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%e4%bd%bf%e7%94%a8%e9%80%92%e5%bd%92sql%e6%9d%a5%e7%94%9f%e6%88%90%e6%95%b0%e6%8d%ae aria-label=锚点>#</a></span></h3><p>公用表表达式（Common Table Express，也叫 <strong>CTE</strong>）是 <strong>SQL</strong> 中声明变量的唯一方法（有别于 <strong>PostgreSQL</strong> 和 <strong>Sybase SQL</strong> 中的 Window 语句）</p><p>她是一个强大的概念。异常强大。看看下面的语句：</p><pre><code>ichexw=# WITH
  t1(v1, v2) AS (SELECT 1, 2),
  t2(w1, w2) AS (
    SELECT v1 * 2, v2 * 2
    FROM t1
  )
SELECT *
FROM t1, t2;
 v1 | v2 | w1 | w2
----+----+----+----
  1 |  2 |  2 |  4
(1 row)
</code></pre><p>使用一个简单的 <code>WITH</code> 语法，你可以指定一个 Table 对象列表（记住：一切都是表），她们可以相互调用。</p><p>这个很容易理解。这使得 <strong>CTE</strong> 很有用，并且她们还允许递归这种逆天的特性！现在看看下面的 <strong>PostgreSQL</strong> 语句：</p><pre><code>ichexw=# WITH RECURSIVE t(v) AS (
  SELECT 1     -- Seed Row
  UNION ALL
  SELECT v + 1 -- Recursion
  FROM t
)
SELECT v
FROM t
LIMIT 5;
 v
---
 1
 2
 3
 4
 5
(5 rows)
</code></pre><p>是不是很不错？看看注解，还是挺简单易用的。你定义了一个 <strong>CTE</strong> 实际上就是两个 <code>UNION ALL</code> 子查询</p><p>第一个 <code>UNION ALL</code> 子查询称之为 “种子行（SEED ROW）”。她初始化了递归。她可以在后续的递归中生成一个或多行。记住：一切都是表，因此我们的递归生成的也是表，而不是一个独立的行或值。</p><p>第二个 <code>UNION ALL</code> 子查询进行递归。如果你认真看，你会发现她是从 <code>t</code> 中检索数据的；例如 第二个子查询允许从我们声明的 <strong>CTE</strong> 中查询。递归。因此，她也能访问 CTE 中定义的 <code>v</code> 字段。</p><p>在我们的例子中，把 row(1) 作为递归的种子，然后进行 <code>v+1</code> 的递归。这个递归通过设置一个 <code>LIMIT 5</code> 来作为停止条件的（是不是很很像 JAVA8 STREAM 中的潜在无限递归）。</p><div id=side-note图灵完备 class=anchor></div><h4 class="relative group">Side note：图灵完备
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#side-note%e5%9b%be%e7%81%b5%e5%ae%8c%e5%a4%87 aria-label=锚点>#</a></span></h4><p>递归 CTE 使 SQL:1999 具有图灵完备，她意味着任何其他语言都可以使用 SQL 来重写！（如果你足够疯狂的话）</p><p>下面可能在很多博客经常看到的一个令人影响深刻的例子：曼德博集合（The Mandelbrot Set）, e.g. 比如在 on <a href=http://explainextended.com/2013/12/31/happy-new-year-5/ target=_blank>http://explainextended.com/2013/12/31/happy-new-year-5/</a></p><pre><code>ichexw=# WITH RECURSIVE q(r, i, rx, ix, g) AS (
SELECT r::DOUBLE PRECISION * 0.02, i::DOUBLE PRECISION * 0.02,
    .0::DOUBLE PRECISION      , .0::DOUBLE PRECISION, 0
FROM generate_series(-60, 20) r, generate_series(-50, 50) i
UNION ALL
SELECT r, i, CASE WHEN abs(rx * rx + ix * ix) &lt;= 2 THEN rx * rx - ix * ix END + r,
           CASE WHEN abs(rx * rx + ix * ix) &lt;= 2 THEN 2 * rx * ix END + i, g + 1
FROM q
WHERE rx IS NOT NULL AND g &lt; 99
)
SELECT array_to_string(array_agg(s ORDER BY r), '')
FROM (
SELECT i, r, substring(' .:-=+*#%@', max(g) / 10 + 1, 1) s
FROM q
GROUP BY i, r
) q
GROUP BY i
ORDER BY i;
finance=# WITH RECURSIVE q(r, i, rx, ix, g) AS (
SELECT r::DOUBLE PRECISION * 0.02, i::DOUBLE PRECISION * 0.02,
    .0::DOUBLE PRECISION      , .0::DOUBLE PRECISION, 0
FROM generate_series(-60, 20) r, generate_series(-50, 50) i
UNION ALL
SELECT r, i, CASE WHEN abs(rx * rx + ix * ix) &lt;= 2 THEN rx * rx - ix * ix END + r,
           CASE WHEN abs(rx * rx + ix * ix) &lt;= 2 THEN 2 * rx * ix END + i, g + 1
FROM q
WHERE rx IS NOT NULL AND g &lt; 99
)
SELECT array_to_string(array_agg(s ORDER BY r), '')
FROM (
SELECT i, r, substring(' .:-=+*#%@', max(g) / 10 + 1, 1) s
FROM q
GROUP BY i, r
) q
GROUP BY i
ORDER BY i;
----------------------------------------------------------------------------------
                                                     ..... ..@
                                                     ..:..:.
                                                      .....
                                                      ..:..
                                                      ..:..
                                                     ..-:..
                                                 .....=@#+:
                                                ....:.=@@=.....
                                               :.-..+@*@*::..:.
                                               ..:-@@@@@@@@:.:-.
                                                ..@@@@@@@@@+%..
                                                ..@@@@@@@@@@-..
                                                :-*@@@@@@@@@:-:
                                               ..:@@@@@@@@@@@..
                                              ...*@@@@@@@@@@:..
                                   .        ......-@@@@@@@@@....               .
                                .....    ..:.......=@@@@@@@-........:          ..
                              .-.:-.......==..*.=.::-@@@@@:::.:.@..*-.         =.
                              ...=...=...::+%.@:@@@@@@@@@@@@@+*#=.=:+-.      ..-
                              .:.:=::*....@@@@@@@@@@@@@@@@@@@@@@@@=@@.....::...:.
                              ...*@@@@=.@:@@@@@@@@@@@@@@@@@@@@@@@@@@=.=....:...::.
                               .::@@@@@:-@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@..-:@=*:::.
                               .-@@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.=@@@@=..:
                               ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@@@@@:..
                              ....:-*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@::
                             .....@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-..
                           .....@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-:...
                          .--:+.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@...
                          .==@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-..
                          ..+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-#.
                          ...=+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
                          -.=-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..:
                         .*%:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:@-
  .    ..:...           ..-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 ..............        ....-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%@=
 .--.-.....-=.:..........::@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
 ..=:-....=@+..=.........@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:.
 .:+@@::@==@-*:%:+.......:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
 ::@@@-@@@@@@@@@-:=.....:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:
 .:@@@@@@@@@@@@@@@=:.....%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 .:@@@@@@@@@@@@@@@@@-...:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:-
 :@@@@@@@@@@@@@@@@@@@-..%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
 %@@@@@@@@@@@@@@@@@@@-..-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
 @@@@@@@@@@@@@@@@@@@@@::+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+
 @@@@@@@@@@@@@@@@@@@@@@:@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
 @@@@@@@@@@@@@@@@@@@@@@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@-
 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..
 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.
:
</code></pre><p>被 shock 到了吧？</p><div id=3-计算运行总计 class=anchor></div><h3 class="relative group">3. 计算运行总计
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-%e8%ae%a1%e7%ae%97%e8%bf%90%e8%a1%8c%e6%80%bb%e8%ae%a1 aria-label=锚点>#</a></span></h3><p>在 <strong>Microsoft Excel</strong> 中，你会简单地计算前两个（或后续）的值之和（或差），然后使用有用的十字光标在整个电子表格中拖动该公式。</p><p>您通过电子表格计算运行总计。</p><p>在 SQL 的世界中，最好的方法就是使用窗口函数（Window Function）。</p><p>窗口函数是一个很强大的概念-首先，她表面上看不那么好理解，但实际上真的很简单：</p><blockquote><p>窗口函数是相对于由SELECT转换的当前行的行的子集上的聚合/排名</p></blockquote><p>就这么简单，^_^</p><p>它本质上意味着窗口函数可以对当前行“之上”或“之下”的行执行计算。不像常规的聚合和分组，它们不会转换行，这使它们非常有用。</p><p>语法可以归纳如下：</p><pre><code>function(...) OVER (
  PARTITION BY ...
  ORDER BY ...
  ROWS BETWEEN ... AND ...
)
</code></pre><p>一次，我有各种排序函数（我们将在后面一一解释这些函数），仅接着是 <code>OVER()</code> 分句，她指定了窗口，定义如下：</p><ul><li><code>PARTITION</code>: 只有与当前行在同一分区中的行才会被视为该窗口</li><li><code>ORDER</code>: 我们可以给筛选出来的窗口进行排序</li><li><code>ROWS</code>（或 <code>RANGE</code>）帧定义：窗口可以被限制为“之前”和“之后”的固定量的行。</li></ul><p>这就是窗口函数的全部。</p><p>现在，我们来看看，她如何为我们实现计算运行总计？下面是数据</p><table><thead><tr><th>ID</th><th>VALUE_DATE</th><th>AMOUNT</th><th>BALANCE</th></tr></thead><tbody><tr><td>9997</td><td>2014-03-18</td><td>99.17</td><td>19985.81</td></tr><tr><td>9981</td><td>2014-03-16</td><td>71.44</td><td>19886.64</td></tr><tr><td>9979</td><td>2014-03-16</td><td>-94.60</td><td>19815.20</td></tr><tr><td>9977</td><td>2014-03-16</td><td>-6.96</td><td>19909.80</td></tr><tr><td>9971</td><td>2014-03-15</td><td>-65.95</td><td>19916.76</td></tr></tbody></table><p>我们假设 BALANCE 就是我们想要数值。</p><p>直观地，我们可以立即看出规律（看加重符号,加上符号）</p><table><thead><tr><th>ID</th><th>VALUE_DATE</th><th>AMOUNT</th><th>BALANCE</th></tr></thead><tbody><tr><td>9997</td><td>2014-03-18</td><td><strong>-(99.17)</strong></td><td><strong>+19985.81</strong></td></tr><tr><td>9981</td><td>2014-03-16</td><td><strong>-(71.44)</strong></td><td>19886.64</td></tr><tr><td>9979</td><td>2014-03-16</td><td><strong>-(-94.60)</strong></td><td>19815.20</td></tr><tr><td>9977</td><td>2014-03-16</td><td>-6.96</td><td><strong>=19909.80</strong></td></tr><tr><td>9971</td><td>2014-03-15</td><td>-65.95</td><td>19916.76</td></tr></tbody></table><p>因此，我们可以使用下面伪 SQL 语句来表达任何的任何余额：</p><pre><code>当前的月 - SUM(进出款项金额) OVER (
  &quot;当前行之上的所有行&quot;
)
</code></pre><p>实际的 SQL 可以写成这样：</p><pre><code>SUM(t.amount) OVER (
  PARTITION BY t.account_id 
  ORDER BY     t.value_date DESC, t.id DESC
  ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
)
</code></pre><p>解释如下：</p><ul><li>分区可以计算每一个银行账户的汇总，而不是全部数据的</li><li>汇总之前，排序保证交易在分区内是有序的</li><li><code>ROWS</code> 分句讲只考虑分区内之前的行（给定的排序）的汇总</li></ul><p>所有这些都将发生在内存中的数据集已经由您在FROM .. WHERE等子句中选择，因此非常快。</p><div id=中场休息 class=anchor></div><h3 class="relative group">中场休息
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e4%b8%ad%e5%9c%ba%e4%bc%91%e6%81%af aria-label=锚点>#</a></span></h3><p>在我们介绍其他技巧之前，大家思考下：我们已经看到了</p><ul><li>（递归）Common Table Expressions(公共表表达式,CTE)</li><li>窗口函数</li></ul><p>她们都有共同的特征：</p><ul><li>很棒</li><li>异常强大</li><li>声明式</li><li>SQL 标准的一部分</li><li>在大部分关系型数据库可用(除了 MySQL)</li><li>非常重要构件</li></ul><p>如果一定要从这个文章中得出什么结论的话，那就是你绝对应该知道现代的SQL这两个重要构件。为什么？可以从这个 <a href=https://modern-sql.com/ target=_blank>站点中</a> 中得到答案。</p><div id=4-寻找连续无间隔的最长子序列 class=anchor></div><h3 class="relative group">4. 寻找连续无间隔的最长子序列
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4-%e5%af%bb%e6%89%be%e8%bf%9e%e7%bb%ad%e6%97%a0%e9%97%b4%e9%9a%94%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e5%ba%8f%e5%88%97 aria-label=锚点>#</a></span></h3><p>很多应用或者网站为了刺激用户活跃留存，对连续登录的用户进行奖励。比如，StackOverflow 的徽章：</p><ul><li>Enthusianst: 连续30天访问每天都访问的用户</li><li>Fanatic：连续100天访问每天都访问的用户</li></ul><p>那我们如何计算这些徽章呢？这些徽章用来奖励给连续使用他们平台指定天数的用户。不管婚礼或者结婚纪念日，你也必须登录，否则计数就会归0。</p><p>正如我们所使用的是声明式编程，我不需要当心维护任何状态和内存计数。我们想要使用在线分析 SQL 的形式表达她。例如，看看这些数据（测试数据生成方法见附录-1）：</p><pre><code>n3xt-test=# SELECT login_time FROM user_login WHERE id = :user_id;
     login_time
---------------------
 2017-02-17 16:00:00
 2017-02-16 20:00:00
 2017-02-16 03:00:00
 2017-02-15 21:00:00
 2017-02-15 20:00:00
 2017-02-14 01:00:00
 2017-02-12 09:00:00
 2017-02-11 00:00:00
 2017-02-10 20:00:00
 2017-02-10 10:00:00
 2017-02-09 20:00:00
 2017-02-09 05:00:00
 2017-02-08 19:00:00
(13 rows)
</code></pre><p>一点帮助都没有。让我们从时间戳中去掉小时，并去重。这很简单：</p><pre><code>n3xt-test=# SELECT DISTINCT CAST(login_time AS DATE) login_date FROM user_login WHERE id = :user_id;
 login_date
------------
 2017-02-17
 2017-02-16
 2017-02-15
 2017-02-14
 2017-02-12
 2017-02-11
 2017-02-10
 2017-02-09
 2017-02-08
(9 rows)
</code></pre><p>就是现在，使用我们已经学过的窗口函数，让我们给每一个日期加上简单的行数：</p><pre><code>n3xt-test=# SELECT
    login_date,
    row_number() OVER (ORDER BY login_date)
FROM login_date;
 login_date | row_number
------------+------------
 2017-02-08 |          1
 2017-02-09 |          2
 2017-02-10 |          3
 2017-02-11 |          4
 2017-02-12 |          5
 2017-02-14 |          6
 2017-02-15 |          7
 2017-02-16 |          8
 2017-02-17 |          9
(9 rows)
</code></pre><p>接下来仍然很简单。看看发生了什么，如果不单独选择这些值，我们减去它们？</p><pre><code>n3xt-test=# SELECT
    login_date,
    (row_number() OVER (ORDER BY login_date)),
    login_date - (row_number() OVER (ORDER BY login_date))::INT grp
FROM login_date;
 login_date | row_number |    grp
------------+------------+------------
 2017-02-08 |          1 | 2017-02-07
 2017-02-09 |          2 | 2017-02-07
 2017-02-10 |          3 | 2017-02-07
 2017-02-11 |          4 | 2017-02-07
 2017-02-12 |          5 | 2017-02-07
 2017-02-14 |          6 | 2017-02-08
 2017-02-15 |          7 | 2017-02-08
 2017-02-16 |          8 | 2017-02-08
 2017-02-17 |          9 | 2017-02-08
(9 rows)
</code></pre><p>上述这些简单例子来说明了：</p><ol><li><code>ROW_NUMBER()</code> 不言而喻，不会有间隔。</li><li>然而我们的数据有</li></ol><p>因此，我们把不连续有间隔的时间序列减去一个连续的整数序列，得到的新的日期相同的时间处在同一个连续日期：</p><pre><code>n3xt-test=# SELECT
  min(login_date), max(login_date),
  max(login_date) -
  min(login_date) + 1 AS length
FROM login_date_groups
GROUP BY grp
ORDER BY length DESC;
    min     |    max     | length
------------+------------+--------
 2017-02-08 | 2017-02-12 |      5
 2017-02-14 | 2017-02-17 |      4
(2 rows)
</code></pre><p>下面是完整的查询语句：</p><pre><code>1 WITH login_date AS (
2     SELECT DISTINCT CAST(login_time AS DATE) login_date
3     FROM user_login
4     WHERE id = 1
5 ), login_date_groups AS (
6     SELECT
7         login_date,
8         (row_number() OVER (ORDER BY login_date)),
9         login_date - (row_number() OVER (ORDER BY login_date))::INT grp
10     FROM login_date
11 )
12 SELECT
13   min(login_date), max(login_date),
14   max(login_date) -
15   min(login_date) + 1 AS length
16 FROM login_date_groups
17 GROUP BY grp
18 ORDER BY length DESC;
</code></pre><div id=5-寻找序列长度 class=anchor></div><h3 class="relative group">5. 寻找序列长度
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-%e5%af%bb%e6%89%be%e5%ba%8f%e5%88%97%e9%95%bf%e5%ba%a6 aria-label=锚点>#</a></span></h3><p>上一个例子，我们已经提取连续值的序列。很简单，我们几乎滥用了整数连续队列。倘若序列的定义不够直观，？看看接下来的数据，<strong>LENGTH</strong> 是我们想计算的每一个序列的长度：</p><table><thead><tr><th>id</th><th>amount</th><th>length</th></tr></thead><tbody><tr><td>20</td><td>13.97</td><td>3</td></tr><tr><td>19</td><td>21.13</td><td>3</td></tr><tr><td>18</td><td>84.72</td><td>3</td></tr><tr><td>17</td><td>-18.91</td><td>2</td></tr><tr><td>16</td><td>-65.99</td><td>2</td></tr><tr><td>15</td><td>18.07</td><td>1</td></tr><tr><td>14</td><td>-52.68</td><td>1</td></tr><tr><td>13</td><td>16.87</td><td>1</td></tr><tr><td>12</td><td>-56.76</td><td>2</td></tr><tr><td>11</td><td>-94.72</td><td>2</td></tr><tr><td>10</td><td>95.46</td><td>1</td></tr><tr><td>9</td><td>-52.45</td><td>1</td></tr></tbody></table><p>是的，你的猜测是正确，这个是收支方向（<code>SIGN(AMOUNT)</code>）相同根据订单ID排序生成的连续序列，看下格式化后的数据：</p><table><thead><tr><th>id</th><th>amount</th><th>length</th></tr></thead><tbody><tr><td>20</td><td>+13.97</td><td>3</td></tr><tr><td>19</td><td>+21.13</td><td>3</td></tr><tr><td>18</td><td>+84.72</td><td>3</td></tr><tr><td>17</td><td>-18.91</td><td>2</td></tr><tr><td>16</td><td>-65.99</td><td>2</td></tr><tr><td>15</td><td>+18.07</td><td>1</td></tr><tr><td>14</td><td>-52.68</td><td>1</td></tr><tr><td>13</td><td>+16.87</td><td>1</td></tr><tr><td>12</td><td>-56.76</td><td>2</td></tr><tr><td>11</td><td>-94.72</td><td>2</td></tr><tr><td>10</td><td>+95.46</td><td>1</td></tr><tr><td>9</td><td>-52.45</td><td>1</td></tr></tbody></table><p>那我们要怎么做？太简单，首先去除所有的噪音，加入行数</p><pre><code>n3xt-test=# SELECT
  id, amount,
  sign(amount) AS sign,
  row_number()
    OVER (ORDER BY id DESC) AS rn
FROM orders;
 id | amount | sign | rn
----+--------+------+----
 20 |  13.97 |    1 |  1
 19 |  21.13 |    1 |  2
 18 |  84.72 |    1 |  3
 17 | -18.91 |   -1 |  4
 16 | -65.99 |   -1 |  5
 15 |  18.07 |    1 |  6
 14 | -52.68 |   -1 |  7
 13 |  16.87 |    1 |  8
 12 | -56.76 |   -1 |  9
</code></pre><p>下一个目标是生成下面这样的表：</p><table><thead><tr><th>id</th><th>amount</th><th>sign</th><th>rn</th><th>lo</th><th>hi</th></tr></thead><tbody><tr><td>20</td><td>13.97</td><td>1</td><td>1</td><td>1</td><td></td></tr><tr><td>19</td><td>21.13</td><td>1</td><td>2</td><td></td><td></td></tr><tr><td>18</td><td>84.72</td><td>1</td><td>3</td><td></td><td>3</td></tr><tr><td>17</td><td>-18.91</td><td>-1</td><td>4</td><td>4</td><td></td></tr><tr><td>16</td><td>-65.99</td><td>-1</td><td>5</td><td></td><td>5</td></tr><tr><td>15</td><td>18.07</td><td>1</td><td>6</td><td>6</td><td>6</td></tr><tr><td>14</td><td>-52.68</td><td>-1</td><td>7</td><td>7</td><td>7</td></tr><tr><td>13</td><td>16.87</td><td>1</td><td>8</td><td>8</td><td>8</td></tr><tr><td>12</td><td>-56.76</td><td>-1</td><td>9</td><td>9</td><td></td></tr><tr><td>11</td><td>-94.72</td><td>-1</td><td>10</td><td></td><td>10</td></tr><tr><td>10</td><td>95.46</td><td>1</td><td>11</td><td>11</td><td>11</td></tr></tbody></table><p>在这个表中，我想复制行数到一个子系列的起始行（下界）的 <em>LO</em> 字段，和结束行（上界）的 <em>HI</em> 字段中。为了这个，我们需要使用两个魔法函数 <code>LEAD()</code> 和 <code>LAG()</code>：</p><ul><li><p><code>LEAD()</code>：当前行的下 n 行</p></li><li><p><code>LAG()</code>：当前行的上 n 行</p><pre><code>  n3xt-test=# SELECT
    lag(v) OVER (ORDER BY v),
    v,
    lead(v) OVER (ORDER BY v)
  FROM (
    VALUES (1), (2), (3), (4)
  ) t(v);
   lag | v | lead
  -----+---+------
       | 1 |    2
     1 | 2 |    3
     2 | 3 |    4
     3 | 4 |
  (4 rows)
</code></pre></li></ul><p>很神奇有木有？记住，在窗口函数内，你可以对 <strong>和当前相关的行的子集</strong> 进行排行或者聚合。在 <code>LEAD()</code> 和 <code>LAG()</code> 的例子中，我们访问当前行相关的行，重要指定偏离位置，是很容易的。在很多场景中时很有用的。</p><p>继续我的 <em>LO</em> 和 <em>HGIH</em> 例子：</p><pre><code>SELECT
  trx.*,
  CASE WHEN lag(sign)
       OVER (ORDER BY id DESC) != sign
       THEN rn END AS lo,
  CASE WHEN lead(sign)
       OVER (ORDER BY id DESC) != sign
       THEN rn END AS hi
FROM trx;
</code></pre><p>通过与上一行（<code>lag()</code>）对比 <em>sign</em> 字段，如果他们符号相反，我们把当前的行数复制到 <em>LO</em> 字段，因为这是我们序列的下界。</p><p>然后通过与下一行（<code>lead()</code>）对比 <em>sign</em> 字段，如果他们符号相反，我们把当前的行数复制到 <em>LO</em> 字段，因为这是我们序列的上界。</p><p>最后，我们需要处理讨厌的空值（<code>NULL</code>）：</p><pre><code>SELECT -- With NULL handling...
  trx.*,
  CASE WHEN coalesce(lag(sign)
       OVER (ORDER BY id DESC), 0) != sign
       THEN rn END AS lo,
  CASE WHEN coalesce(lead(sign)
       OVER (ORDER BY id DESC), 0) != sign
       THEN rn END AS hi
FROM trx;
</code></pre><p>下一步，我们想要 <em>LO</em> 和 <em>HI</em> 出现在我们的所有行中。</p><table><thead><tr><th>id</th><th>amount</th><th>sign</th><th>rn</th><th>lo</th><th>hi</th></tr></thead><tbody><tr><td>20</td><td>13.97</td><td>1</td><td>1</td><td>1</td><td>3</td></tr><tr><td>19</td><td>21.13</td><td>1</td><td>2</td><td>1</td><td>3</td></tr><tr><td>18</td><td>84.72</td><td>1</td><td>3</td><td>1</td><td>3</td></tr><tr><td>17</td><td>-18.91</td><td>-1</td><td>4</td><td>4</td><td>5</td></tr><tr><td>16</td><td>-65.99</td><td>-1</td><td>5</td><td>4</td><td>5</td></tr><tr><td>15</td><td>18.07</td><td>1</td><td>6</td><td>6</td><td>6</td></tr><tr><td>14</td><td>-52.68</td><td>-1</td><td>7</td><td>7</td><td>7</td></tr><tr><td>13</td><td>16.87</td><td>1</td><td>8</td><td>8</td><td>8</td></tr><tr><td>12</td><td>-56.76</td><td>-1</td><td>9</td><td>9</td><td>10</td></tr><tr><td>11</td><td>-94.72</td><td>-1</td><td>10</td><td>9</td><td>10</td></tr><tr><td>10</td><td>95.46</td><td>1</td><td>11</td><td>11</td><td>11</td></tr></tbody></table><p>我们所使用的特性至少在 Redshift，Sybase SQL，DB2 以及 Oracle 中都可用。我们使用 <code>IGNORE NULLS</code> 语句：</p><pre><code>SELECT 
  trx.*,
  last_value (lo) IGNORE NULLS OVER (
    ORDER BY id DESC 
    ROWS BETWEEN UNBOUNDED PRECEDING 
    AND CURRENT ROW) AS lo,
  first_value(hi) IGNORE NULLS OVER (
    ORDER BY id DESC 
    ROWS BETWEEN CURRENT ROW 
    AND UNBOUNDED FOLLOWING) AS hi
FROM trx
</code></pre><p>很多关键字！但是本质往往是相同的。在任何给定的当前行，我们寻找之前的值（previous values，<code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>），但是忽略所有的空值。从之前的之中，我们获取最后的值，和我们的新 <em>LO</em> 值。换句话说，我们获取向前最接近当前行（closest preceding）的 <em>LO</em> 值。</p><p><em>HI</em> 也是同理。在任何给定的当前行，我们寻找随后的值（subsequent values，<code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>），但是忽略所有的空值。从之前的之中，我们获取最后的值，和我们的新 <em>HI</em> 值。换句话说，我们获取向后最接近当前行（closest following）的 <em>HI</em> 值。</p><pre><code>SELECT -- With NULL handling...
  trx.*,
  coalesce(last_value (lo) IGNORE NULLS OVER (
    ORDER BY id DESC 
    ROWS BETWEEN UNBOUNDED PRECEDING 
    AND CURRENT ROW), rn) AS lo,
  coalesce(first_value(hi) IGNORE NULLS OVER (
    ORDER BY id DESC 
    ROWS BETWEEN CURRENT ROW 
    AND UNBOUNDED FOLLOWING), rn) AS hi
FROM trx
</code></pre><p>最后，我们只是做一个微不足道的最后一步，记住处理 <strong>off-by-1</strong> 错误：</p><pre><code>SELECT
  trx.*,
  1 + hi - lo AS length
FROM trx
</code></pre><p>这个是我们最后的结果：</p><table><thead><tr><th>id</th><th>amount</th><th>sign</th><th>rn</th><th>lo</th><th>hi</th><th>length</th></tr></thead><tbody><tr><td>20</td><td>13.97</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td></tr><tr><td>19</td><td>21.13</td><td>1</td><td>2</td><td>1</td><td>3</td><td>3</td></tr><tr><td>18</td><td>84.72</td><td>1</td><td>3</td><td>1</td><td>3</td><td>3</td></tr><tr><td>17</td><td>-18.91</td><td>-1</td><td>4</td><td>4</td><td>5</td><td>2</td></tr><tr><td>16</td><td>-65.99</td><td>-1</td><td>5</td><td>4</td><td>5</td><td>2</td></tr><tr><td>15</td><td>18.07</td><td>1</td><td>6</td><td>6</td><td>6</td><td>1</td></tr><tr><td>14</td><td>-52.68</td><td>-1</td><td>7</td><td>7</td><td>7</td><td>1</td></tr><tr><td>13</td><td>16.87</td><td>1</td><td>8</td><td>8</td><td>8</td><td>1</td></tr><tr><td>12</td><td>-56.76</td><td>-1</td><td>9</td><td>9</td><td>10</td><td>2</td></tr><tr><td>11</td><td>-94.72</td><td>-1</td><td>10</td><td>9</td><td>10</td><td>2</td></tr><tr><td>10</td><td>95.46</td><td>1</td><td>11</td><td>11</td><td>11</td><td>1</td></tr></tbody></table><p>下面是完整版的查询：</p><pre><code>WITH 
  trx1(id, amount, sign, rn) AS (
    SELECT id, amount, sign(amount), row_number() OVER (ORDER BY id DESC)
    FROM trx
  ),
  trx2(id, amount, sign, rn, lo, hi) AS (
    SELECT trx1.*,
    CASE WHEN coalesce(lag(sign) OVER (ORDER BY id DESC), 0) != sign 
         THEN rn END,
    CASE WHEN coalesce(lead(sign) OVER (ORDER BY id DESC), 0) != sign 
         THEN rn END
    FROM trx1
  )
SELECT 
  trx2.*, 1
  - last_value (lo) IGNORE NULLS OVER (ORDER BY id DESC 
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
  + first_value(hi) IGNORE NULLS OVER (ORDER BY id DESC 
    ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
FROM trx2
</code></pre><p>由于 <strong>PostgreSQL</strong> 没有 <code>IGNORE NULLS</code> 语句，所以我在给出一个实现：</p><pre><code>WITH trx AS (
  SELECT
    id, amount,
    sign(amount) AS sign,
    row_number()
      OVER (ORDER BY id DESC) AS rn
  FROM orders
), trx1 AS (
  SELECT
    trx.*,
    CASE WHEN coalesce(lag(sign)
         OVER (ORDER BY id DESC), 0) != sign
         THEN rn END AS lo,
    CASE WHEN coalesce(lead(sign)
         OVER (ORDER BY id DESC), 0) != sign
         THEN rn END AS hi
  FROM trx
), trx2 AS (
 SELECT -- 数据对齐
    trx1.*,
    sum(case when lo is null then 0 else 1 end) over (order by id desc) as lo_partition
 FROM trx1
)
SELECT
  trx2.id, trx2.amount, trx2.sign, trx2.rn,
  max(trx2.lo) OVER (PARTITION BY trx2.lo_partition) lo,
  max(trx2.hi) OVER (PARTITION BY trx2.lo_partition) hi,
  max(trx2.hi) OVER (PARTITION BY trx2.lo_partition) -
  max(trx2.lo) OVER (PARTITION BY trx2.lo_partition) + 1 length
FROM trx2;
</code></pre><div id=6-子集和問題the-subset-sum-problem-with-sql class=anchor></div><h3 class="relative group">6. 子集和問題（The subset sum problem with SQL）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6-%e5%ad%90%e9%9b%86%e5%92%8c%e5%95%8f%e9%a1%8cthe-subset-sum-problem-with-sql aria-label=锚点>#</a></span></h3><p>什么是子集和问题？这里进行了有趣的解释：</p><p><a href=https://xkcd.com/287 target=_blank>https://xkcd.com/287</a></p><p>还是维基百科上乏味的解释：</p><p><a href=https://zh.wikipedia.org/wiki/%E5%AD%90%E9%9B%86%E5%92%8C%E5%95%8F%E9%A1%8C target=_blank>子集和问题</a></p><p>本质上，对每一个的求和。。。</p><table><thead><tr><th>ID</th><th>TOTAL</th></tr></thead><tbody><tr><td>1</td><td>25150</td></tr><tr><td>2</td><td>19800</td></tr><tr><td>3</td><td>27511</td></tr></tbody></table><p>我想要尽可能地从这些组合项中找到“最好”的和：</p><table><thead><tr><th>ID</th><th>ITEM</th></tr></thead><tbody><tr><td>1</td><td>7120</td></tr><tr><td>2</td><td>8150</td></tr><tr><td>3</td><td>8255</td></tr><tr><td>4</td><td>9051</td></tr><tr><td>5</td><td>1220</td></tr><tr><td>6</td><td>12515</td></tr><tr><td>7</td><td>13555</td></tr><tr><td>8</td><td>5221</td></tr><tr><td>9</td><td>812</td></tr><tr><td>10</td><td>6562</td></tr></tbody></table><p>如果你心算够好的话，你可以直接得出最佳的和：</p><table><thead><tr><th>TOTAL</th><th>SUM</th><th>CALC</th></tr></thead><tbody><tr><td>25150</td><td>25133</td><td>7120 + 8150 + 9051 + 812</td></tr><tr><td>19800</td><td>19768</td><td>1220 + 12515 + 5221 + 812</td></tr><tr><td>27511</td><td>27488</td><td>8150 + 8255 + 9051 + 1220 + 812</td></tr></tbody></table><p>使用 <strong>SQL</strong> 怎么处理呢？简单，只需要使用创建一个 <strong>CTE</strong>，枚举出 2的n次方种减1个组合，并找到最接近的一个：</p><pre><code>-- 枚举所有的组合，2**n - 1 组合
WITH sums(sum, max_id, calc) AS (...)
-- 找出最接近 total 的那一条
SELECT
  totals.total,
  something_something(total - sum) AS best,
  something_something(total - sum) AS calc
FROM draw_the_rest_of_the_*bleep*_owl
</code></pre><p>如果你读到这里，说明我们是真朋友，^_^</p><p>不要担心，方法并没有想象中那么难。</p><p>首先，我们需要枚举所有子集合(实现全排列的算法)，这个比较简单：</p><pre><code>WITH RECURSIVE
assign(id, total) AS ( ... ),
vals(id, item) AS (...),
sums (start_id, max_id, sum, cacl) AS (
  SELECT id, id, item, item::text FROM vals
  UNION ALL
  SELECT
    sums.start_id, t.id, sum+item,
    cacl|| '+' || item::text
  FROM sums JOIN vals t ON sums.max_id &lt; t.id
)
SELECT * FROM sums
</code></pre><p>然后，我们把需要结果从候选组合中找到最接近的组合：</p><pre><code>SELECT total, sum, cacl
FROM assign a, LATERAL (
    SELECT sum, cacl FROM sums
    ORDER BY ABS(a.total - sum)
    FETCH FIRST 1 ROW ONLY	-- 等同于 limit 1，这个是 SQL 标准，limit 不是
) b;
</code></pre><p>为 <em>ASSIGN</em> 的每个值通过和 <em>SUMS</em> 连表获取按照排序的的一行的值。我们需要使用 <code>LATERAL</code>，因为他允许我们访问左边的表的字段，否则正常的 <code>JOIN</code> 无法直接获取的。</p><p>同样的功能在 <strong>SQL Server</strong>（它的关键字是 <code>CROSS APPLY</code>） 也支持。</p><p>在连表的右侧的结果依赖于左边的时候，<code>LATERAL</code> 可能很有用。与普通连接不同，这意味着 <code>JOIN</code> 顺序将从左到右依次设置，优化器具有一组减少的连接算法选项。想现在这个场景（带着 <code>ORDER BY</code> 和 <code>FETCH FRIST</code>），或者连接非嵌套的表值函数。</p><p>下面是完整的查询。</p><pre><code>n3xt-test=# WITH RECURSIVE
assign(id, total) AS (
            SELECT 1, 25150
  UNION ALL SELECT 2, 19800
  UNION ALL SELECT 3, 27511
),
vals (id, item) AS (
            SELECT 1 , 7120
  UNION ALL SELECT 2 , 8150
  UNION ALL SELECT 3 , 8255
  UNION ALL SELECT 4 , 9051
  UNION ALL SELECT 5 , 1220
  UNION ALL SELECT 6 , 12515
  UNION ALL SELECT 7 , 13555
  UNION ALL SELECT 8 , 5221
  UNION ALL SELECT 9 , 812
  UNION ALL SELECT 10, 6562
),
sums (start_id, max_id, sum, cacl) AS (
  SELECT id, id, item, item::text FROM vals
  UNION ALL
  SELECT
    sums.start_id, t.id, sum+item,
    cacl|| '+' || item::text
  FROM sums JOIN vals t ON sums.max_id &lt; t.id
)
SELECT total, sum, cacl
FROM assign a, LATERAL (
    SELECT sum, cacl FROM sums
    ORDER BY ABS(a.total - sum)
    FETCH FIRST 1 ROW ONLY
) b;
 total |  sum  |          cacl
-------+-------+-------------------------
 25150 | 25133 | 7120+8150+9051+812
 19800 | 19768 | 1220+12515+5221+812
 27511 | 27488 | 8150+8255+9051+1220+812
(3 rows)
</code></pre><div id=7-覆盖运行中的汇总 class=anchor></div><h3 class="relative group">7. 覆盖运行中的汇总
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#7-%e8%a6%86%e7%9b%96%e8%bf%90%e8%a1%8c%e4%b8%ad%e7%9a%84%e6%b1%87%e6%80%bb aria-label=锚点>#</a></span></h3><p>之前，我们已经知道怎么使用窗口函数计算“一般的”运行中汇总。很简单。现在，如果我们想要覆盖运行中的汇总，使得她永远大于0？基本上，我们星耀计算这个：</p><table><thead><tr><th>DATE</th><th>AMOUNT</th><th>TOTAL</th></tr></thead><tbody><tr><td>2012-01-01</td><td>800</td><td>800</td></tr><tr><td>2012-02-01</td><td>1900</td><td>2700</td></tr><tr><td>2012-03-01</td><td>1750</td><td>4450</td></tr><tr><td>2012-04-01</td><td>-20000</td><td>0</td></tr><tr><td>2012-05-01</td><td>900</td><td>900</td></tr><tr><td>2012-06-01</td><td>3900</td><td>4800</td></tr><tr><td>2012-07-01</td><td>-2600</td><td>2200</td></tr><tr><td>2012-08-01</td><td>-2600</td><td>0</td></tr><tr><td>2012-09-01</td><td>2100</td><td>2100</td></tr><tr><td>2012-10-01</td><td>-2400</td><td>0</td></tr><tr><td>2012-11-01</td><td>1100</td><td>1100</td></tr><tr><td>2012-12-01</td><td>1300</td><td>2400</td></tr></tbody></table><p>当一笔很大支出 -20000 被剪去，我将其归0即可，而不是显示世纪的 -15550。看我的注释就明白了：</p><table><thead><tr><th>DATE</th><th>AMOUNT</th><th>TOTAL</th><th>Total 的公式</th></tr></thead><tbody><tr><td>2012-01-01</td><td>800</td><td>800</td><td><strong>GREATEST(0, 800)</strong></td></tr><tr><td>2012-02-01</td><td>1900</td><td>2700</td><td><strong>GREATEST(0, 2700)</strong></td></tr><tr><td>2012-03-01</td><td>1750</td><td>4450</td><td><strong>GREATEST(0, 4450)</strong></td></tr><tr><td>2012-04-01</td><td>-20000</td><td>0</td><td><strong>GREATEST(0, -15550)</strong></td></tr><tr><td>2012-05-01</td><td>900</td><td>900</td><td><strong>GREATEST(0, 900)</strong></td></tr><tr><td>2012-06-01</td><td>3900</td><td>4800</td><td><strong>GREATEST(0, 4800)</strong></td></tr><tr><td>2012-07-01</td><td>-2600</td><td>2200</td><td><strong>GREATEST(0, 2200)</strong></td></tr><tr><td>2012-08-01</td><td>-2600</td><td>0</td><td><strong>GREATEST(0, -400)</strong></td></tr><tr><td>2012-09-01</td><td>2100</td><td>2100</td><td><strong>GREATEST(0, 2100)</strong></td></tr><tr><td>2012-10-01</td><td>-2400</td><td>0</td><td><strong>GREATEST(0, -300)</strong></td></tr><tr><td>2012-11-01</td><td>1100</td><td>1100</td><td><strong>GREATEST(0, 1100)</strong></td></tr><tr><td>2012-12-01</td><td>1300</td><td>2400</td><td><strong>GREATEST(0, 2400)</strong></td></tr></tbody></table><p>我们怎么做呢？窗口函数和递归CTE都是可以实现，看到这里大家估计也已经视觉疲劳了，我们换个新法子？但是这个法子只有 <strong>Oracle</strong>，vendor-specific SQL。</p><p>将会非常的惊艳，只需要在任何报表的后面加上 <code>MODEL</code>：</p><pre><code>SELECT ... FROM some_table

-- 放在任何表后面	 
MODEL ...
</code></pre><p>然后你就可以直接在 <strong>SQL</strong> 语句中实现电子表格的逻辑，和 <strong>Excel</strong> 一样。</p><p>下面是接下来三个语句将非常实用和广泛的使用</p><pre><code>MODEL
  -- 维度
  DIMENSION BY ...
   
  -- 报表字段
  MEASURES ...
   
  -- 公司
  RULES ...
</code></pre><p>稍微解释下：</p><ul><li><code>DIMENSION BY</code>：指定电子表格的维度。不像 <strong>Excel</strong>，你可以在 <strong>Oracle</strong> 中指定任意数量的维度，而不是2个。</li><li><code>MEASURES</code>：可用的值。不像 Excel ，在单元格中可以使用元祖，而不是单一的值。</li><li><code>RULES</code>：每一个单元格的公式。不像 Excel，这个公式集中放在这里，而不是在每一个单元格中。</li></ul><p>使得 <code>MODEL</code> 使用起来比 <strong>Excel</strong> 难一些，但是功能更强大，如果你敢用。下面给一个小 demo：</p><pre><code>SELECT *
FROM (
  SELECT date, amount, 0 AS total
  FROM amounts
)
MODEL 
  DIMENSION BY (row_number() OVER (ORDER BY date) AS rn)
  MEASURES (date, amount, total)
  RULES (
    total[any] = greatest(0,
    coalesce(total[cv(rn) - 1], 0) + amount[cv(rn)])
  )
</code></pre><div id=8-时间序列模式识别time-series-pattern-recognition class=anchor></div><h3 class="relative group">8. 时间序列模式识别（Time Series Pattern Recognition）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#8-%e6%97%b6%e9%97%b4%e5%ba%8f%e5%88%97%e6%a8%a1%e5%bc%8f%e8%af%86%e5%88%abtime-series-pattern-recognition aria-label=锚点>#</a></span></h3><p>如果你对诈骗识别或者其他运行实时大数据的领域感兴趣，时间模式识别这个名词对你来说将不会太陌生。</p><p>如果我们重温 <strong>5. 寻找序列长度</strong> 的章节，将会想在我们时间序列的复杂事件（<strong>Event</strong>）上生成触发器（<strong>Trigger</strong>）：</p><table><thead><tr><th>ID</th><th>VALUE_DATE</th><th>AMOUNT</th><th>LEN</th><th>TRIGGER</th></tr></thead><tbody><tr><td>9997</td><td>2014-03-18</td><td>+ 99.17</td><td>1</td><td></td></tr><tr><td>9981</td><td>2014-03-16</td><td>- 71.44</td><td>4</td><td></td></tr><tr><td>9979</td><td>2014-03-16</td><td>- 94.60</td><td>4</td><td>x</td></tr><tr><td>9977</td><td>2014-03-16</td><td>- 6.96</td><td>4</td><td></td></tr><tr><td>9971</td><td>2014-03-15</td><td>- 65.95</td><td>4</td><td></td></tr><tr><td>9964</td><td>2014-03-15</td><td>+ 15.13</td><td>3</td><td></td></tr><tr><td>9962</td><td>2014-03-15</td><td>+ 17.47</td><td>3</td><td></td></tr><tr><td>9960</td><td>2014-03-15</td><td>+ 3.55</td><td>3</td><td></td></tr><tr><td>9959</td><td>2014-03-14</td><td>- 32.00</td><td>1</td><td></td></tr></tbody></table><p>触发器的规则是：</p><blockquote><p>如果某个事件连续发生3次，则触发该触发器（<strong>Trigger</strong>）。</p></blockquote><p>也和之前的 <code>MODEL</code> 语句类似，我们能做的就是使用 <strong>Oracle 12c</strong> 语法：</p><pre><code>SELECT ... FROM some_table	 
MATCH_RECOGNIZE (...) 
</code></pre><p><code>MATCH_RECOGNIZE</code> 的最简单的应用包括以下子句：</p><pre><code>SELECT *
FROM series
MATCH_RECOGNIZE (
  -- 模式匹配在这个顺序下完成
  ORDER BY ...
 
  -- 用来匹配的字段
  MEASURES ...
 
  -- 每一次匹配后返回行的配置
  ALL ROWS PER MATCH
 
  -- 匹配事件的正则表达式
  PATTERN (...)
 
  -- 事件的定义
  DEFINE ...
) 
</code></pre><p>这个听起来太疯狂了。现在看一个实际的例子：</p><pre><code>SELECT *
FROM series
MATCH_RECOGNIZE (
  ORDER BY id
  MEASURES classifier() AS trg
  ALL ROWS PER MATCH
  PATTERN (S (R X R+)?)
  DEFINE
    R AS sign(R.amount) = prev(sign(R.amount)),
    X AS sign(X.amount) = prev(sign(X.amount))
) 
</code></pre><p>我们做了什么？</p><ul><li>根据 <em>ID</em> 排序</li><li>然后我们指定我们想要的值作为结果。 我们需要 <code>MEASURE</code> 触发器（<strong>Trigger</strong>），它被定义为分类器，即我们将在模式中使用的文字。 此外，我们想要匹配的所有行。</li><li>我们指定类正则表达式模式。这个模式是一个 <em>S</em> 事件（<strong>Event</strong>）定义开始，接着 <em>R</em> 时间定义重复。如果全部模式匹配，我们会的得到 <em>SRXR</em>，<em>SRXRR</em> 或 <em>SRXRRR</em>，例如， X 将会在序列长度大于 4 的第三个位置北标记</li><li>最后，我们定义 <em>R</em> 和 <em>X</em> 成同一个事件（<strong>Event</strong>），即当前行和上一行的 <code>SIGN(AMOUNT)</code> 相同时触发。我们没有定义 <em>S</em>，他可以是任何的其他行。</li></ul><p>这个查询会产生下面魔法般的输出：</p><table><thead><tr><th>ID</th><th>VALUE_DATE</th><th>AMOUNT</th><th>TRG</th></tr></thead><tbody><tr><td>9997</td><td>2014-03-18</td><td>+ 99.17</td><td>S</td></tr><tr><td>9981</td><td>2014-03-16</td><td>- 71.44</td><td>R</td></tr><tr><td>9979</td><td>2014-03-16</td><td>- 94.60</td><td>X</td></tr><tr><td>9977</td><td>2014-03-16</td><td>- 6.96</td><td>R</td></tr><tr><td>9971</td><td>2014-03-15</td><td>- 65.95</td><td>S</td></tr><tr><td>9964</td><td>2014-03-15</td><td>+ 15.13</td><td>S</td></tr><tr><td>9962</td><td>2014-03-15</td><td>+ 17.47</td><td>S</td></tr><tr><td>9960</td><td>2014-03-15</td><td>+ 3.55</td><td>S</td></tr><tr><td>9959</td><td>2014-03-14</td><td>- 32.00</td><td>S</td></tr></tbody></table><p>我们可以看到一个 <em>X</em> 在我们的事件（<strong>Event</strong>）系统。这个就是实际上我们想要的。在一系列长度大于3的事件（相同符号）的第三次重复时触发。</p><p>Boom！</p><p>实际上，我们根本不 Care <em>S</em> 和 <em>R</em> 事件（<strong>Event</strong>），只需要像这样去掉就好：</p><pre><code>SELECT
  id, value_date, amount, 
  CASE trg WHEN 'X' THEN 'X' END trg
FROM series
MATCH_RECOGNIZE (
  ORDER BY id
  MEASURES classifier() AS trg
  ALL ROWS PER MATCH
  PATTERN (S (R X R+)?)
  DEFINE
    R AS sign(R.amount) = prev(sign(R.amount)),
    X AS sign(X.amount) = prev(sign(X.amount))
) 
</code></pre><p>最后的结果如下：</p><table><thead><tr><th>ID</th><th>VALUE_DATE</th><th>AMOUNT</th><th>TRG</th></tr></thead><tbody><tr><td>9997</td><td>2014-03-18</td><td>+ 99.17</td><td></td></tr><tr><td>9981</td><td>2014-03-16</td><td>- 71.44</td><td></td></tr><tr><td>9979</td><td>2014-03-16</td><td>- 94.60</td><td>X</td></tr><tr><td>9977</td><td>2014-03-16</td><td>- 6.96</td><td></td></tr><tr><td>9971</td><td>2014-03-15</td><td>- 65.95</td><td></td></tr><tr><td>9964</td><td>2014-03-15</td><td>+ 15.13</td><td></td></tr><tr><td>9962</td><td>2014-03-15</td><td>+ 17.47</td><td></td></tr><tr><td>9960</td><td>2014-03-15</td><td>+ 3.55</td><td></td></tr><tr><td>9959</td><td>2014-03-14</td><td>- 32.00</td><td></td></tr></tbody></table><p>感谢， <strong>ORACLE</strong>！</p><p>另外别要期待我继续介绍 <strong>Oracle</strong> 白皮书（如果你在使用 <strong>Oracle 12c</strong>, 那强烈建议看一下她的<a href=http://www.oracle.com/ocom/groups/public/@otn/documents/webcontent/1965433.pdf target=_blank>
文档</a>）的其他特性了。</p><div id=9-数据表行列转换pivoting-and-unpivoting class=anchor></div><h3 class="relative group">9. 数据表行列转换（Pivoting and Unpivoting）
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#9-%e6%95%b0%e6%8d%ae%e8%a1%a8%e8%a1%8c%e5%88%97%e8%bd%ac%e6%8d%a2pivoting-and-unpivoting aria-label=锚点>#</a></span></h3><p>如果你已经读到这里，接下来的内容都太简单了，和大家过一下：</p><p>这是我们的数据，<strong>主演</strong>，<strong>电影名</strong>以及<strong>电影评级</strong>：</p><table><thead><tr><th>NAME</th><th>TITLE</th><th>RATING</th></tr></thead><tbody><tr><td>A. GRANT</td><td>ANNIE IDENTITY</td><td>G</td></tr><tr><td>A. GRANT</td><td>DISCIPLE MOTHER</td><td>PG</td></tr><tr><td>A. GRANT</td><td>GLORY TRACY</td><td>PG-13</td></tr><tr><td>A. HUDSON</td><td>LEGEND JEDI</td><td>PG</td></tr><tr><td>A. CRONYN</td><td>IRON MOON</td><td>PG</td></tr><tr><td>A. CRONYN</td><td>LADY STAGE</td><td>PG</td></tr><tr><td>B. WALKEN</td><td>SIEGE MADRE</td><td>R</td></tr></tbody></table><p>我们想要转换成：</p><table><thead><tr><th>NAME</th><th>NC-17</th><th>PG</th><th>G</th><th>PG-13</th><th>R</th></tr></thead><tbody><tr><td>A. GRANT</td><td>3</td><td>6</td><td>5</td><td>3</td><td>1</td></tr><tr><td>A. HUDSON</td><td>12</td><td>4</td><td>7</td><td>9</td><td>2</td></tr><tr><td>A. CRONYN</td><td>6</td><td>9</td><td>2</td><td>6</td><td>4</td></tr><tr><td>B. WALKEN</td><td>8</td><td>8</td><td>4</td><td>7</td><td>3</td></tr><tr><td>B. WILLIS</td><td>5</td><td>5</td><td>14</td><td>3</td><td>6</td></tr><tr><td>C. DENCH</td><td>6</td><td>4</td><td>5</td><td>4</td><td>5</td></tr><tr><td>C. NEESON</td><td>3</td><td>8</td><td>4</td><td>7</td><td>3</td></tr></tbody></table><p>如果是用过 <strong>Excel</strong> 的 <strong>透视表</strong> 的可以略过接下来的两段解释。</p><p>大家注意到了，我可以根据演员进行分组，然后把该演员每个评级分组下的电影数量<strong>转化成列（PIVOTING）</strong>。不以关系的形式显示，（例如，每组一行），我们把所有的组都转换成列。之所以可以这么做，是因为我们实现知道所有可能出现的分组。</p><p><strong>列转行（Unpivoting）</strong> 则是相反的操作。</p><table><thead><tr><th>NAME</th><th>RATING</th><th>COUNT</th></tr></thead><tbody><tr><td>A. GRANT</td><td>NC-17</td><td>3</td></tr><tr><td>A. GRANT</td><td>PG</td><td>6</td></tr><tr><td>A. GRANT</td><td>G</td><td>5</td></tr><tr><td>A. GRANT</td><td>PG-13</td><td>3</td></tr><tr><td>A. GRANT</td><td>R</td><td>6</td></tr><tr><td>A. HUDSON</td><td>NC-17</td><td>12</td></tr><tr><td>A. HUDSON</td><td>PG</td><td>4</td></tr></tbody></table><p>这个实际上很简单。下面是 PostgreSQL 的实现：</p><pre><code>SELECT
  first_name, last_name,
  count(*) FILTER (WHERE rating = 'NC-17') AS &quot;NC-17&quot;,
  count(*) FILTER (WHERE rating = 'PG'   ) AS &quot;PG&quot;,
  count(*) FILTER (WHERE rating = 'G'    ) AS &quot;G&quot;,
  count(*) FILTER (WHERE rating = 'PG-13') AS &quot;PG-13&quot;,
  count(*) FILTER (WHERE rating = 'R'    ) AS &quot;R&quot;
FROM actor AS a
JOIN film_actor AS fa USING (actor_id)
JOIN film AS f USING (film_id)
GROUP BY actor_id
</code></pre><p>我们可以向聚合函数附加一个简单的 <code>FILTER</code> 子句，以便只计算相关的数据。</p><p>在其他数据库下，我们可以这么做：</p><pre><code>SELECT
  first_name, last_name,
  count(CASE rating WHEN 'NC-17' THEN 1 END) AS &quot;NC-17&quot;,
  count(CASE rating WHEN 'PG'    THEN 1 END) AS &quot;PG&quot;,
  count(CASE rating WHEN 'G'     THEN 1 END) AS &quot;G&quot;,
  count(CASE rating WHEN 'PG-13' THEN 1 END) AS &quot;PG-13&quot;,
  count(CASE rating WHEN 'R'     THEN 1 END) AS &quot;R&quot;
FROM actor AS a
JOIN film_actor AS fa USING (actor_id)
JOIN film AS f USING (film_id)
GROUP BY actor_id
</code></pre><p>现在，如果你在使用 <strong>SQL Server</strong> 或者 <strong>Oracle</strong> 的话，你还可以使用内建的 <code>PIVOT</code> 或 <code>UNPIVOT</code> 语句，就像 <code>MODEL</code> 和 <code>MATCH_RECOGNIZE</code> 一样，在一个表的后面添加新的关键词就好：</p><pre><code>-- 行转列
SELECT something, something
FROM some_table
PIVOT (
  count(*) FOR rating IN (
    'NC-17' AS &quot;NC-17&quot;, 
    'PG'    AS &quot;PG&quot;, 
    'G'     AS &quot;G&quot;, 
    'PG-13' AS &quot;PG-13&quot;, 
    'R'     AS &quot;R&quot;
  )
)
 
-- 列转行
SELECT something, something
FROM some_table
UNPIVOT (
  count    FOR rating IN (
    &quot;NC-17&quot; AS 'NC-17', 
    &quot;PG&quot;    AS 'PG', 
    &quot;G&quot;     AS 'G', 
    &quot;PG-13&quot; AS 'PG-13', 
    &quot;R&quot;     AS 'R'
  )
)
</code></pre><div id=10-滥用-xml-和-json class=anchor></div><h3 class="relative group">10. 滥用 XML 和 JSON
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#10-%e6%bb%a5%e7%94%a8-xml-%e5%92%8c-json aria-label=锚点>#</a></span></h3><p>首先</p><blockquote><p>JSON 只是更少特性和语法的 XML</p></blockquote><p>现在，所有人都知道 <strong>XML</strong> 很棒。必然的结果是：</p><blockquote><p>JSON 就逊多了</p></blockquote><p>不要使用 <strong>JSON</strong>。</p><p>现在我们已经解决了这一点，我们可以安全地忽略正在进行的 <strong>JSON</strong> 数据库中的炒作（你们大多数将在五年后遗憾），并继续到最后的例子。 如何在数据库中做XML。</p><p>给定一个原始的 <strong>XML</strong> 文档，我们想要解析他，不要在每个演员中嵌套逗号分隔的电影列表，在一个表中产生演员/电影的无范式表示。</p><p>开始，我们接下来要写三个 <strong>CTE</strong>：</p><p>第一个，我们简单的解析 XML。下面使用 PostgreSQL：</p><pre><code>n3xt-test=# WITH RECURSIVE
  x(v) AS (SELECT '
&lt;actors&gt;
  &lt;actor&gt;
    &lt;first-name&gt;Bud&lt;/first-name&gt;
    &lt;last-name&gt;Spencer&lt;/last-name&gt;
    &lt;films&gt;God Forgives... I Don’t, Double Trouble, They Call Him Bulldozer&lt;/films&gt;
  &lt;/actor&gt;
  &lt;actor&gt;
    &lt;first-name&gt;Terence&lt;/first-name&gt;
    &lt;last-name&gt;Hill&lt;/last-name&gt;
    &lt;films&gt;God Forgives... I Don’t, Double Trouble, Lucky Luke&lt;/films&gt;
  &lt;/actor&gt;
&lt;/actors&gt;'::xml)
SELECT *
FROM x;
</code></pre><p>简单。</p><p>然后，我们使用 <strong>XPATH</strong> 来提取 <strong>XML</strong> 结构中的每一个值，并把它放到字段中：</p><pre><code>n3xt-test=# WITH RECURSIVE
  x(v) AS (SELECT '...'::xml), 
  actors(actor_id, first_name, last_name, films) AS (
    SELECT
      row_number() OVER (),
      (xpath('//first-name/text()', t.v))[1]::TEXT,
      (xpath('//last-name/text()' , t.v))[1]::TEXT,
      (xpath('//films/text()'     , t.v))[1]::TEXT
    FROM unnest(xpath('//actor', (SELECT v FROM x))) t(v)
  )
SELECT *
FROM actors;
 actor_id | first_name | last_name |                              films
----------+------------+-----------+------------------------------------------------------------------
        1 | Bud        | Spencer   | God Forgives... I Don’t, Double Trouble, They Call Him Bulldozer
        2 | Terence    | Hill      | God Forgives... I Don’t, Double Trouble, Lucky Luke
(2 rows)
</code></pre><p>同样很简单。</p><p>最后，使用递归正则表达式模式匹配，然后就结束教程吗^_^</p><pre><code>n3xt-test=# WITH RECURSIVE
  x(v) AS (SELECT '...'::xml),
  actors(actor_id, first_name, last_name, films) AS (...),
  films(actor_id, first_name, last_name, film_id, film) AS (
    SELECT actor_id, first_name, last_name, 1,
      regexp_replace(films, ',.+', '')
    FROM actors
    UNION ALL
    SELECT actor_id, a.first_name, a.last_name, f.film_id + 1,
      regexp_replace(a.films, '.*' || f.film || ', ?(.*?)(,.+)?', '\1')
    FROM films AS f
    JOIN actors AS a USING (actor_id)
    WHERE a.films NOT LIKE '%' || f.film
  )
SELECT *
FROM films;
 actor_id | first_name | last_name | film_id |          film
----------+------------+-----------+---------+-------------------------
        1 | Bud        | Spencer   |       1 | God Forgives... I Don’t
        2 | Terence    | Hill      |       1 | God Forgives... I Don’t
        1 | Bud        | Spencer   |       2 | Double Trouble
        2 | Terence    | Hill      |       2 | Double Trouble
        1 | Bud        | Spencer   |       3 | They Call Him Bulldozer
        2 | Terence    | Hill      |       3 | Lucky Luke
(6 rows)
</code></pre><p>开始总结陈词：</p><div id=解语 class=anchor></div><h3 class="relative group">解语
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e8%a7%a3%e8%af%ad aria-label=锚点>#</a></span></h3><p>这文章中所有的内容都是声明式的。并且相对简单。当然，我尝试然这篇文章更有趣味性，一切夸张的 SQL 被采用，并让大部分东西都比较易学。也不是都很简单，你必须多练习写 <strong>SQL</strong>。和其他语言一样，但是稍微难度大一点，因为：</p><ol><li>时不时出现比较晦涩的语法</li><li>使用声明式的思想并不太容易。至少，和面向对象和面向过程式的思想差异很大。</li></ol><p>但是一旦你习惯了，使用 <strong>SQL</strong> 的 <strong>声明式编程</strong> 还是值得你学习的。您可以通过描述要从数据库获取的结果，在非常少的代码中表达您的数据之间的复杂关系。</p><p>是不是很棒？</p><div id=附录-1-随机生成用户登录行为 class=anchor></div><h3 class="relative group">附录-1: 随机生成用户登录行为:
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%99%84%e5%bd%95-1-%e9%9a%8f%e6%9c%ba%e7%94%9f%e6%88%90%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e8%a1%8c%e4%b8%ba aria-label=锚点>#</a></span></h3><pre><code>  1 CREATE TABLE user_login AS
  2 WITH RECURSIVE users(id) AS (
  3     SELECT 1
  4     UNION ALL
  5     SELECT id + 1
  6     FROM users WHERE id &lt;= 20
  7 )
  8 SELECT u.id,  login_time.login_time
  9 FROM
 10 (SELECT id FROM users) u,
 11 LATERAL(
 12     SELECT login_date.*, login_time.*
 13     FROM
 14     (SELECT date(generate_series(now() - '10 days'::INTERVAL, now(), '1 day')) login_date, (random()*6)::int login_per_day) login_date,
 15     LATERAL(
 16         SELECT * FROM
 17         generate_series(login_date.login_date, login_date.login_date + '1 days'::INTERVAL, '1 hour') login_time
 18         ORDER BY random() LIMIT login_date.login_per_day
 19     ) login_time
 20 ) login_time
 21 ORDER BY login_time DESC;
</code></pre><div id=附录-2-生成订单数据 class=anchor></div><h3 class="relative group">附录-2: 生成订单数据：
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%e9%99%84%e5%bd%95-2-%e7%94%9f%e6%88%90%e8%ae%a2%e5%8d%95%e6%95%b0%e6%8d%ae aria-label=锚点>#</a></span></h3><pre><code>1 CREATE TABLE orders AS
2 SELECT *, round((100-random()*200)::NUMERIC, 2) amount
3 FROM generate_series(1, 20) id;
</code></pre><blockquote><p>参考文献：</p><ul><li><a href=https://blog.jooq.org/2016/04/25/10-sql-tricks-that-you-didnt-think-were-possible/ target=_blank>10 SQL Tricks That You Didn’t Think</a></li><li><a href=https://blog.jooq.org/2015/10/26/how-to-find-the-closest-subset-sum-with-sql/ target=_blank>How to Find the Closest Subset Sum with SQL</a></li><li><a href=http://stackoverflow.com/questions/38467298/how-to-correctly-use-fetch-first-in-postgresql target=_blank>如何在 PostgreSQL 中正确使用 FETCH FIRST?</a></li><li><a href=https://zh.wikipedia.org/wiki/%E5%AD%90%E9%9B%86%E5%92%8C%E5%95%8F%E9%A1%8C target=_blank>子集和问题</a></li></ul></blockquote></div></div><script>var oid="views_posts/2017-02-13-10-sql-tricks-that-you-didnt-think-were-possible.md",oid_likes="likes_posts/2017-02-13-10-sql-tricks-that-you-didnt-think-were-possible.md"</script><script type=text/javascript src=/n3xtchen/js/page.min.0e49973b4ad0a382c7c6012d8bff8226316642daabc4f8a20477bd08674f3da6e2fa993bc20ad4f51e7c5bb68e6f913a207a7c4fe37ea0e7b806894afce0a64e.js integrity="sha512-DkmXO0rQo4LHxgEti/+CJjFmQtqrxPiiBHe9CGdPPabi+pk7wgrU9R58W7aOb5E6IHp8T+N+oOe4BolK/OCmTg=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/n3xtchen/2017/01/24/spark200---window-function/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Spark 实现简单移动平均值（SMA） - 窗口函数（Window Function）</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2017-01-24 00:00:00 +0000 UTC">2017-01-24</time></span></span></a></span>
<span><a class="flex text-right group ml-3" href=/n3xtchen/2017/03/31/playing-with-postgres-and-kafka/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">让 Postgres 和 Kafka 一起玩耍</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2017-03-31 00:00:00 +0000 UTC">2017-03-31</time></span></span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label title>&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2023
n3xtchen</p><p class="text-xs text-neutral-500 dark:text-neutral-400">由 <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a> 强力驱动</p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/n3xtchen/js/process.min.35c1113bcc16c5a59bf031082f9e63822aa95280423881a7847a7ff33a16e6299ce6a840d9ef4e10d947e030a18f3f20359afb2ec0f35967484b9a9360ac3145.js integrity="sha512-NcERO8wWxaWb8DEIL55jgiqpUoBCOIGnhHp/8zoW5imc5qhA2e9OENlH4DChjz8gNZr7LsDzWWdIS5qTYKwxRQ=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://n3xtchen.github.io/n3xtchen style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title>
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>