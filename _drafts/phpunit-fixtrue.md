---
layout: post
title: "PHPUnit   Fixture"
description: ""
category: php
tags: [php, phpunit, fixture ]
---
{% include JB/setup %}

在编写测试时，最费时的部分之一是编写代码来将整个场景设置成某个已知的状态，并在
测试结束后将其复原到初始状态。这个已知的状态称为测试的基境(fixture)。

PHPUnit 支持共享建立基境的代码。在运行某个测试方法前，会调用一个名叫 setUp() 
的模板方法。 setUp() 是创建测试所用对象的地方。当测试方法运行结束后，不管是成功
还是失败，都会调用另外一个名叫 tearDown() 的模板方法。tearDown() 是清理测试所用
对象的地方。

测试类的每个测试方法都会运行一次 setUp() 与 tearDown() 模板方法（同时，每个测试
方法都是在一个全新的测试类实例上运行的）。

另外，setUpBeforeClass() 与 tearDownAfterClass() 模板方法将分别在测试用例类的第
一个测试运行之前和测试用例类的最后一个测试运行之后调用。


#### setUp() 多 tearDown() 少

理论上说，setUp() 与 tearDown() 是精确对称的，但是实践中并非如此。实际上，只有在
setUp() 中分配了诸如文件或套接字之类的外部资源时才需要实现 tearDown() 。如果 
setUp() 中只创建纯 PHP 对象，通常可以略过 tearDown()。不管怎样，如果在 setUp() 
中创建了大量对象，你可能想要在 tearDown() 中 unset() 指向这些对象的变量，这样它们
就可以被垃圾回收机制回收掉。对测试用例对象的垃圾回收动作则是不可预知的。

#### 变体
如果两个基境建立工作略有不同的测试该怎么办？ 出现这种情况有两个可能性：

+ 如果两个 setUp() 代码仅有微小差异，把有差异的代码内容从 setUp() 移到测试方法内。

+ 如果两个 setUp() 是确实不一样，那么需要另外一个测试用例类。参考基境建立工作的不
同之处来命名这个类。

#### 共享基境

有少数几个很好的理由来在测试之间共享基境，但是大部分情况下，在测试之间共享基境的
需求都是源于某个未解决的设计问题。

一个有实际意义的多测试间共享基境的例子是数据库连接：只登录数据库一次，然后重用此
连接，而不是每个测试都建立一个新的数据库连接。这样能加快测试的运行。

> 需要反复强调的是：在测试之间共享基境会降低测试的价值。潜在的设计问题是对象之间
不是松散耦合的。如果解决掉潜在的设计问题，并使用短连件(stub)编 写测试，就能达成
更好的结果，而不是在测试之间建立运行时依赖并忽略改进设计的机会。
