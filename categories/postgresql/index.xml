<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PostgreSQL on N3xtChen 的博客</title><link>https://n3xtchen.github.io/n3xtchen/categories/postgresql/</link><description>Recent content in PostgreSQL on N3xtChen 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>© 2023 n3xtchen</copyright><lastBuildDate>Sat, 29 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://n3xtchen.github.io/n3xtchen/categories/postgresql/index.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL: 匿名化（Anonymizer）工具</title><link>https://n3xtchen.github.io/n3xtchen/2018/12/29/pgsql-anonymizer/</link><pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2018/12/29/pgsql-anonymizer/</guid><description>PostgreSQL Anonymizer: 在 PostgreSQL 中隐藏或替换个人身份信息（PII）或者商业敏感信息数据。[项目地址：https://gitlab.</description></item><item><title>让 Postgres 和 Kafka 一起玩耍</title><link>https://n3xtchen.github.io/n3xtchen/2017/03/31/playing-with-postgres-and-kafka/</link><pubDate>Fri, 31 Mar 2017 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2017/03/31/playing-with-postgres-and-kafka/</guid><description>Apache Kafka 和 Postgres: 处理事务和报表能力 # Apache Kafka 是目前主流的分布式流处理平台，用于数据处理和信息一致保证。她允许你集中数据流，完成多种目的。我突然对 Mozilla 的数据管道 实现感兴趣，尤其是其中展示了 Kafka 作为流的入口。</description></item><item><title>PostgreSQL 的 For Each 语句 - Lateral 联表</title><link>https://n3xtchen.github.io/n3xtchen/2016/12/07/pgsql-lateral/</link><pubDate>Wed, 07 Dec 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/12/07/pgsql-lateral/</guid><description>LATERAL 的用途，可以是 SELECT 中的结果作为条件，并把查询的结果，直接引用到 SELECT 子句中，先来看一个语句:</description></item><item><title>如何查找和杀掉 PostgreSQL 中长时间运行的查询</title><link>https://n3xtchen.github.io/n3xtchen/2016/08/31/kill-postgresql/</link><pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/08/31/kill-postgresql/</guid><description>长时间运行的查询会影响整体数据库的性能，它们可能停留在一些后台进程中。尤其当遇上表锁的时候，就更蛋疼了，于是有了下面的文章。</description></item><item><title>postgreql performance</title><link>https://n3xtchen.github.io/n3xtchen/2016/05/03/postgreql---performance/</link><pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/05/03/postgreql---performance/</guid><description/></item><item><title>PostgreSQL - 使用 PGXN 安装 oracle-fdw</title><link>https://n3xtchen.github.io/n3xtchen/2016/05/02/postgresql---use-pgxn-install-oracle-fdw/</link><pubDate>Mon, 02 May 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/05/02/postgresql---use-pgxn-install-oracle-fdw/</guid><description>安装 oracle_fdw # 设置环境变量</description></item><item><title>PostgreSQL - 9.5 会成为你的下一个 JSON 数据库?</title><link>https://n3xtchen.github.io/n3xtchen/2016/04/24/postgresql---json/</link><pubDate>Sun, 24 Apr 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/04/24/postgresql---json/</guid><description>TL;DR: 是的，但这不是一个好的问题。</description></item><item><title>PostgreSQL - PostGrest 简介</title><link>https://n3xtchen.github.io/n3xtchen/2015/08/13/postgresql---postgrest/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/08/13/postgresql---postgrest/</guid><description>译自 PostGrest Introduction</description></item><item><title>Postgresql - ROW_NUM(), RANK() 和 DENSE_RANK() 的区别</title><link>https://n3xtchen.github.io/n3xtchen/2015/08/13/postgresql---row_num-rank-dense_rank/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/08/13/postgresql---row_num-rank-dense_rank/</guid><description>pigdb=# WITH T(CateID, ID) AS (SELECT 1,1 UNION ALL SELECT 1,1 UNION ALL SELECT 1,1 UNION ALL SELECT 1,2) SELECT *, RANK() OVER(PARTITION BY CateID ORDER BY ID) , ROW_NUMBER() OVER(PARTITION BY CateID ORDER BY ID), DENSE_RANK() OVER(PARTITION BY CateID ORDER BY ID) FROM T; cateid | id | rank | row_number | dense_rank --------+----+------+------------+------------ 1 | 1 | 1 | 1 | 1 1 | 1 | 1 | 2 | 1 1 | 1 | 1 | 3 | 1 1 | 2 | 4 | 4 | 2 (4 rows)</description></item><item><title>PostgreSQL vs MySQL：取分组数据的前N条纪录</title><link>https://n3xtchen.github.io/n3xtchen/2015/08/13/pgsql-vs-mysql---get-nth-value-per-group/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/08/13/pgsql-vs-mysql---get-nth-value-per-group/</guid><description>测试数据： # +------+------+------------------+ | cate | item | note | +------+------+------------------+ | a | 2 | a的第二个值 | | a | 1 | a的第一个值 | | a | 3 | a的第三个值 | | b | 1 | b的第一个值 | | b | 3 | b的第三个值 | | b | 2 | b的第二个值 | | b | 4 | b的第四个值 | | b | 5 | b的第五个值 | +------+------+------------------+ 建表和准备数据 # 都是通用类型，所以 pgsql 和 mysql 的建表和插表的语句都一样：</description></item><item><title>PostgreSQL - 使用 PGXN 安装 Mysql-fdw</title><link>https://n3xtchen.github.io/n3xtchen/2015/06/17/postgresql--use-pgxn-install-mysql-fdw/</link><pubDate>Wed, 17 Jun 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/06/17/postgresql--use-pgxn-install-mysql-fdw/</guid><description>环境要求 # postgresql 9.</description></item><item><title>简化：将代码移到数据库函数中</title><link>https://n3xtchen.github.io/n3xtchen/2015/06/16/pgsql-move-code-into-database-functions/</link><pubDate>Tue, 16 Jun 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/06/16/pgsql-move-code-into-database-functions/</guid><description>原文引用： Simplify: move code into database functions</description></item><item><title>PostgreSQL 触发器（Trigger）- 创建安全的自增主键</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/14/postgresql---trigger/</link><pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/14/postgresql---trigger/</guid><description>通常情况，常规的 SQL 事件（Event） 应该在普通行为的之前或之后被触发。这个行为可以是对插入的值的类型检查，可以是在插入前的格式化，或者是变更和删除数据之后对相关的表的数据修改。传统的处理方式是通过连接数据库的应用的编码层来做，而不是数据库软件本身。</description></item><item><title>PostgreSQL - 序列（Sequence）</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/10/postgresql---sequence/</link><pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/10/postgresql---sequence/</guid><description>PostgreSQL 中的序列是一个数据库对象，本质上是一个自增器。因此，序列在其他同类型数据库软件中以 autoincrment 值的形式存在。在一张表需要非随机，唯一标实符的场景下，Sequence 非常有用。</description></item><item><title>PostgreSQL - 数组(Array)</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/05/postgresql---array/</link><pubDate>Sun, 05 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/05/postgresql---array/</guid><description>PostgreSQL 可以通过一种数据结构在独立字段中存储非原子的值。这个数据结构就是我们今天要谈的数组（Array），它本身不是一种数据类型，而是任何数据类型的一种拓展。</description></item><item><title>PostgreSQL - 继承（inheritance）</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/04/postgresql---inheritance/</link><pubDate>Sat, 04 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/04/postgresql---inheritance/</guid><description>PostgreSQL 支持高级的 objdect-relational 机制，继承。继承允许一张表继承一张（或多张）表的列属性，来建立 parent-child 关系。子表可以继承父表的字段以及约束，同时可以拥有自己的字段。</description></item></channel></rss>