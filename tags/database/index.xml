<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>database on N3xtChen 的博客</title><link>https://n3xtchen.github.io/n3xtchen/tags/database/</link><description>Recent content in database on N3xtChen 的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>© 2023 n3xtchen</copyright><lastBuildDate>Sun, 04 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://n3xtchen.github.io/n3xtchen/tags/database/index.xml" rel="self" type="application/rss+xml"/><item><title>JDBC 的驱动类型</title><link>https://n3xtchen.github.io/n3xtchen/2016/09/04/2016-09-04-jdbc-type/</link><pubDate>Sun, 04 Sep 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/09/04/2016-09-04-jdbc-type/</guid><description>闲的无事，满试着总结归纳下：</description></item><item><title>postgreql performance</title><link>https://n3xtchen.github.io/n3xtchen/2016/05/03/2016-05-03-postgreql---performance/</link><pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/05/03/2016-05-03-postgreql---performance/</guid><description/></item><item><title>PostgreSQL - 使用 PGXN 安装 oracle-fdw</title><link>https://n3xtchen.github.io/n3xtchen/2016/05/02/2016-05-02-postgresql---use-pgxn-install-oracle-fdw/</link><pubDate>Mon, 02 May 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/05/02/2016-05-02-postgresql---use-pgxn-install-oracle-fdw/</guid><description>安装 oracle_fdw # 设置环境变量</description></item><item><title>PostgreSQL - 9.5 会成为你的下一个 JSON 数据库?</title><link>https://n3xtchen.github.io/n3xtchen/2016/04/24/2016-04-24-postgresql---json/</link><pubDate>Sun, 24 Apr 2016 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2016/04/24/2016-04-24-postgresql---json/</guid><description>TL;DR: 是的，但这不是一个好的问题。</description></item><item><title>PostgreSQL - PostGrest 简介</title><link>https://n3xtchen.github.io/n3xtchen/2015/08/13/2015-08-13-postgresql---postgrest/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/08/13/2015-08-13-postgresql---postgrest/</guid><description>译自 PostGrest Introduction</description></item><item><title>Postgresql - ROW_NUM(), RANK() 和 DENSE_RANK() 的区别</title><link>https://n3xtchen.github.io/n3xtchen/2015/08/13/2015-08-13-postgresql---row_num-rank-dense_rank/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/08/13/2015-08-13-postgresql---row_num-rank-dense_rank/</guid><description>pigdb=# WITH T(CateID, ID) AS (SELECT 1,1 UNION ALL SELECT 1,1 UNION ALL SELECT 1,1 UNION ALL SELECT 1,2) SELECT *, RANK() OVER(PARTITION BY CateID ORDER BY ID) , ROW_NUMBER() OVER(PARTITION BY CateID ORDER BY ID), DENSE_RANK() OVER(PARTITION BY CateID ORDER BY ID) FROM T; cateid | id | rank | row_number | dense_rank --------+----+------+------------+------------ 1 | 1 | 1 | 1 | 1 1 | 1 | 1 | 2 | 1 1 | 1 | 1 | 3 | 1 1 | 2 | 4 | 4 | 2 (4 rows)</description></item><item><title>PostgreSQL vs MySQL：取分组数据的前N条纪录</title><link>https://n3xtchen.github.io/n3xtchen/2015/08/13/2015-08-13-pgsql-vs-mysql---get-nth-value-per-group/</link><pubDate>Thu, 13 Aug 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/08/13/2015-08-13-pgsql-vs-mysql---get-nth-value-per-group/</guid><description>测试数据： # +------+------+------------------+ | cate | item | note | +------+------+------------------+ | a | 2 | a的第二个值 | | a | 1 | a的第一个值 | | a | 3 | a的第三个值 | | b | 1 | b的第一个值 | | b | 3 | b的第三个值 | | b | 2 | b的第二个值 | | b | 4 | b的第四个值 | | b | 5 | b的第五个值 | +------+------+------------------+ 建表和准备数据 # 都是通用类型，所以 pgsql 和 mysql 的建表和插表的语句都一样：</description></item><item><title>PostgreSQL - 使用 PGXN 安装 Mysql-fdw</title><link>https://n3xtchen.github.io/n3xtchen/2015/06/17/2015-06-17-postgresql--use-pgxn-install-mysql-fdw/</link><pubDate>Wed, 17 Jun 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/06/17/2015-06-17-postgresql--use-pgxn-install-mysql-fdw/</guid><description>环境要求 # postgresql 9.</description></item><item><title>简化：将代码移到数据库函数中</title><link>https://n3xtchen.github.io/n3xtchen/2015/06/16/2015-06-16-pgsql-move-code-into-database-functions/</link><pubDate>Tue, 16 Jun 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/06/16/2015-06-16-pgsql-move-code-into-database-functions/</guid><description>原文引用： Simplify: move code into database functions</description></item><item><title>PostgreSQL 触发器（Trigger）- 创建安全的自增主键</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/14/2015-04-14-postgresql---trigger/</link><pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/14/2015-04-14-postgresql---trigger/</guid><description>通常情况，常规的 SQL 事件（Event） 应该在普通行为的之前或之后被触发。这个行为可以是对插入的值的类型检查，可以是在插入前的格式化，或者是变更和删除数据之后对相关的表的数据修改。传统的处理方式是通过连接数据库的应用的编码层来做，而不是数据库软件本身。</description></item><item><title>PostgreSQL - 序列（Sequence）</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/10/2015-04-10-postgresql---sequence/</link><pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/10/2015-04-10-postgresql---sequence/</guid><description>PostgreSQL 中的序列是一个数据库对象，本质上是一个自增器。因此，序列在其他同类型数据库软件中以 autoincrment 值的形式存在。在一张表需要非随机，唯一标实符的场景下，Sequence 非常有用。</description></item><item><title>PostgreSQL - 数组(Array)</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/05/2015-04-05-postgresql---array/</link><pubDate>Sun, 05 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/05/2015-04-05-postgresql---array/</guid><description>PostgreSQL 可以通过一种数据结构在独立字段中存储非原子的值。这个数据结构就是我们今天要谈的数组（Array），它本身不是一种数据类型，而是任何数据类型的一种拓展。</description></item><item><title>PostgreSQL - 继承（inheritance）</title><link>https://n3xtchen.github.io/n3xtchen/2015/04/04/2015-04-04-postgresql---inheritance/</link><pubDate>Sat, 04 Apr 2015 00:00:00 +0000</pubDate><guid>https://n3xtchen.github.io/n3xtchen/2015/04/04/2015-04-04-postgresql---inheritance/</guid><description>PostgreSQL 支持高级的 objdect-relational 机制，继承。继承允许一张表继承一张（或多张）表的列属性，来建立 parent-child 关系。子表可以继承父表的字段以及约束，同时可以拥有自己的字段。</description></item></channel></rss>